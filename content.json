{"meta":{"title":"Hexo","subtitle":"Android Developer","description":null,"author":"He He","url":"http://heheliu.github.io.com"},"pages":[],"posts":[{"title":"Effective Java 2","slug":"Effective-Java-2","date":"2017-07-11T06:22:52.000Z","updated":"2017-07-11T08:23:24.124Z","comments":true,"path":"2017/07/11/Effective-Java-2/","link":"","permalink":"http://heheliu.github.io.com/2017/07/11/Effective-Java-2/","excerpt":"","text":"Effective Java第二条 遇到多个构造器参数时要考虑使用构建器静态工厂和构造器有个共同的局限性：它们都不能很好的扩展到大量的可选参数考虑用一个类表示包装食品外面显示的营养成分标签。这些标签中有几个域是必须的，还有超过20个可选域，对于这样的类应该怎么编写呢？1.重叠构造器 public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public NutritionFacts(int sodium, int carbohydrate) { this(sodium,carbohydrate,0,0,0,0); } public NutritionFacts(int sodium, int carbohydrate, int servingSize, int servings, int calories, int fat) { super(); this.servingSize = servingSize; this.servings = servings; this.calories = calories; this.fat = fat; this.sodium = sodium; this.carbohydrate = carbohydrate; } }重叠构造器模式，当参数很多的时候，客户端代码会很难编写，并且难以阅读。调用者需要仔细的数着这些参数去一探究竟。如果不小心颠倒了其中的两个参数的顺序，编译器也不会出错，但是在程序运行时会出现错误。2.JavaBean模式 在这种模式下，调用一个无参构造器来创建对象，然后调用setter方法来设置每个必要的参数，以及每个相关的可选参数。 public class NutritionFacts { private int servingSize = 1; private int servings = 0; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts() { } public void setServingSize(int servingSize) { this.servingSize = servingSize; } public void setServings(int servings) { this.servings = servings; } public void setCalories(int calories) { this.calories = calories; } public void setFat(int fat) { this.fat = fat; } public void setSodium(int sodium) { this.sodium = sodium; } public void setCarbohydrate(int carbohydrate) { this.carbohydrate = carbohydrate; } }调用：NutritionFacts n = new NutritionFacts(); n.setCalories(240); n.setServingSize(2);但是JavaBean自身有很严重的缺点。因为构造过程被分到了几个调用中，在构造过程中JavaBean可能处于不一致的状态。JavaBean模式阻止了把类做成不可变的可能。 3.Builder模式 bulider模式模拟了具名的可选参数 public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Bulider{ //Required parameters private final int servingSize; private final int servings; //optional parameters private int calories; private int fat; private int sodium; private int carbohydrate; public Bulider(int servingSize,int servings){ this.servingSize = servingSize; this.servings = servings; } public Bulider calories(int val){ calories = val; return this; } public Bulider fat(int val){ fat = val; return this; } public Bulider sodium(int val){ sodium = val; return this; } public Bulider carbohydrate(int val){ carbohydrate = val; return this; } public NutritionFacts bulid(){ return new NutritionFacts(this); } } private NutritionFacts(Bulider bulider){ servingSize = bulider.servingSize; servings = bulider.servings; calories = bulider.calories; carbohydrate =bulider.carbohydrate; fat = bulider.fat; sodium = bulider.sodium; } }调用：NutritionFacts n = new NutritionFacts.Bulider(1, 1).calories(2).bulid();Bulider模式不直接生成要想的对象，而是让客户端利用所有必要的参数调用构造器，得到一个Bulider对象，然后客户端在bulider对象上调用类似setter的方法，来设置每个相关的可选参数。最后，客户端调用无参的bulid方法来生成不可变的对象。1总结：如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Bulider模式就是一种不错的选择。","categories":[],"tags":[]},{"title":"Effective Java","slug":"Effective-Java","date":"2017-07-11T01:51:10.000Z","updated":"2017-07-11T05:42:01.782Z","comments":true,"path":"2017/07/11/Effective-Java/","link":"","permalink":"http://heheliu.github.io.com/2017/07/11/Effective-Java/","excerpt":"","text":"分享第一章 创建与销毁对象主题：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时的销毁，以及如何管理对象销毁之前必须进行的各种清理动作 第一条：考虑用静态工厂方法代替构造器对于类而言，为了让客户端获取它自身的一个实例，最常用的就是提供一个共有的构造器，还有另外一个方法就是静态工厂方法。1优势1：它有名称 一个类只能有一个带有指定签名的构造器，如果提供两个构造器，它们的参数列表只在参数类型的顺序上有所不同。使用静态工厂的方法可以确切描述返回的对象，便于阅读，也更为清楚。（BigInteger.probablePrime）1优势2：不必在每次调用的时候都创建一个新的对象 使得不可变类可以使用构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象。1优势3：可以返回原类型的任何子类型的对象 公有的静态工厂方法所返回的对象的类不仅可以是非公有的，而且该类还可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。只要是已声明的返回类型的子类型，都是允许的。1优势4：在创建参数化类型实例的时候，它们使代码变得更加简洁 在调用参数化类的构造器时，即使类型参数很明显，也必须指明。这通常需要连接两次提供类型参数。Map","categories":[],"tags":[]},{"title":"MySql Crash Course","slug":"MySql-Crash-Course","date":"2017-07-10T08:48:51.000Z","updated":"2017-07-10T10:13:06.603Z","comments":true,"path":"2017/07/10/MySql-Crash-Course/","link":"","permalink":"http://heheliu.github.io.com/2017/07/10/MySql-Crash-Course/","excerpt":"","text":"Mysql必知必会因为项目暂停，所以有时间看了一下技术的书。好久没有看技术的书了，看完还是有点心得体会的，所以mark一下，以后要多看技术的书，提高一下专业素养，坚持分享。mysql ,oracle,greenDAO（android的一个第三方的数据库）和之前的项目的salesfores的云平台，我们必不可少的需要接触数据库，当然，这些都是DBMS（数据库管理系统），我们很多时候需要去学习的是怎么使用这些DBMS，也就是数据库的一些操作。MySql是其中一种的数据库管理系统，即是一个数据库软件，但基本语句和操作和其他系统一样，总之，特殊的语句可以在之后用到的时候再去学习。Mysql必知必会这本书是针对关系型数据库的一些基本操作（增删改查）的说明，以及视图，存储过程，触发器，游标，事务处理，引擎的讲解。1.工具123下载地址：https://dev.mysql.com/downloads/ （mysql 5.7.6）建表工具：Navicat for MySql &amp; power designer https://www.navicat.com.cn/download/navicat-for-mysql 2.连接—客户机与服务器123 Mysql 两种启动方式Mysqld – install root password hostname.err (C:\\Users\\hliu110\\Documents\\MySql\\zip\\mysql-5.7.18-win32\\data\\heliu.err)设置密码 3.数据库基础：什么是数据库123456数据库：保存有组织的数据的容器（通常是一个文件或一组文件）表：某种特定类型数据的结构化清单模式（schema）：关于数据库和表的布局及特性的信息列：表中的一个字段，所有表都是由一个或多个列组成行：表中的一个记录主键：一列（或一组列），其值能够唯一区分表中的每个行 4.检索数据:1234567检索单个列:select prod_name from products;检索多个列:select prod_id,prod_name from products;检索所有列:select * from products;排序检索数据:Select prod_name from products order by prod_name desc;过滤数据:Select prod_name,prod_price from products where prod_price = 2.5; 5.用通配符或正则表达式进行搜素12345678910创建计算字段使用数据处理函数分组数据 group by使用子查询联结表组合查询全文本搜索插入数据更新数据删除数据 6.创建和操纵表123456视图存储过程触发器事务处理全球化&amp;本地化安全管理","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-07-05T07:40:46.661Z","updated":"2017-07-10T09:17:40.253Z","comments":true,"path":"2017/07/05/hello-world/","link":"","permalink":"http://heheliu.github.io.com/2017/07/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 搭建博客走过的最大的一个坑：repository 的地址是https而不是ssh.deploy: type: git repository: https://github.com/heheliu/heheliu.github.io.git branch: master","categories":[],"tags":[]}]}